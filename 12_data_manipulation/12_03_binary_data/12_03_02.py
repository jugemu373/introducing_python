# structによるバイナリデータの変換
"""
Pythonは、テキスト操作ツールをいくつも持つ。それに比べて、バイナリデータの為のツールはかなり少ない。
標準ライブラリには、CやC++の構造体に似たデータを処理するstructモジュールが含まれている。structを使えば、
Pythonデータ構造との間でバイナリデータを相互変換できる。

PNGファイルに含まれるデータを使ってこの相互変換の仕組みを説明する。
PNGは、GIF, JPEGと並んで広く使われているイメージ形式である。ここでは、PNGデータからイメージの幅と高さを抽出する
小さなプログラムを作る。

先頭30バイトの値をタイピングしてdataというbytes変数に格納し、これからのコード例で使う(PNG形式の仕様は、幅と高さの情報は最初の24バイトまでに
格納されると規定している。そのため、さしあたりそれ以降の情報は不要となる)。
"""
import struct

valid_png_header = b'\x89PNG\r\n\x1a\n'
data = b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR' + b'\x00\x00\x00\x9a\x00\x00\x00\x8d\x08\x02\x00\x00\x00\xc0'
if data[:8] == valid_png_header:
    width, height = struct.unpack('>LL', data[16:24])
    print('Valid PNG, width', width, 'height', height)
else:
    print('Not a valid PNG')
"""
1. dataは、PNGファイルの先頭30バイトを格納している。なお、ページに収まるようにするために、このコードは2つのバイト列を+で結合している。
2. valid_png_headerには、有効なPNGファイルの先頭を示す8バイトのシーケンスが含まれている。
3. widthは16バイトから19バイト、heightは20から23バイトに格納されている。

>LLは、unpack()に入力バイトシーケンスの解釈方法とPythonデータ型への組み立て方を支持する書式指定文字列である。個々の部品の意味を説明する。

・>は、整数がビッグエンディアン形式で格納されていることを意味する。
・個々のLは、4バイト符号なし整数を指定する。

個々の4バイト値は直接検証できる。
"""
print(data[16:20])
# print(data[20:24]0x9a)
"""
ビッグエンディアンの生成は、最上位バイトが左端にある。幅と高さはどちらも255未満なので、各シーケンスの最後のバイトに収まる。
"""
print(0x9a)
print(0x8d)
"逆に、Pythonデータをバイトに変換したい場合には、structのpack()を使う。"
import struct
print(struct.pack('>L', 154))
print(struct.pack('>L', 141))

"""
エンディアン指定子
指定子  :   バイト順
<       :   リトルエンディアン
>       :   ビッグエンディアン
"""
"""
書式指定子
指定子  :   説明                    :   バイト数
x       :   1バイト読み飛ばし       :   1
b       :   符号付きバイト          :   1
B       :   符号なしバイト          :   1
h       :   符号付き短整数          :   2
H       :   符号なし短整数          :   2
i       :   符号付き整数            :   4
I       :   符号なし整数            :   4
l       :   符号付き整数            :   4
L       :   符号なし整数            :   4
q       :   符号付き整数            :   8
Q       :   符号なし整数            :   8
f       :   単制度浮動小数点数      :   4
d       :   倍精度浮動所数点数      :   8
p       :   countと文字シーケンス   :   1+count
s       :   文字シーケンス          :   count
"""
"""
型指定子は、エンディアン文字の後ろに続く。すべての指定子は前に数値を付けることができる。
その数値は、countを表す。例えば、5BはBBBBBと同じ意味になる。
>LLの変わりにcountプレフィックスを使うと次のようになる。
"""
print(struct.unpack('>2L', data[16:24]))
"""
先ほどはdata[16:24]という書式指定を使ってみたいバイトを直接取り出していたが、x指定子を使って不要なバイトを読み飛ばすこともできる。
"""
print(struct.unpack('>16x2L6x', data))

"""
この書式指定は、次のような意味だ。

・ビッグエンディアン整数形式を使う(>)
・16バイトを読み飛ばす(16x)
・8バイト。2個の符号なし長整数を読み飛ばす(2L)
・最後の6バイトを読み飛ばす
"""
